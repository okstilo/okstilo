# 初めてのPython

はじめに

## I部 Pythonの基礎知識

### 1章 PythonについてのQ&A

Pythonの特徴が書かれている

- 1.3 Pythonの欠点は何ですか？
  - 欠点はパフォーマンス

### 2章 Pythonプログラムの実行

Pythonのインストール方法とかが書かれている

### 3章 プログラムの起動方法

3.1 対話型プログラミング

pythonとすると起動する

```python
$ python
Python 3.11.5 (main, Aug 26 2023, 08:35:59) [Clang 16.0.3 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print 2 ** 8
  File "<stdin>", line 1
    print 2 ** 8
    ^^^^^^^^^^^^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(...)?
```
簡単な掛け算でSyntaxエラーになった。プリントの書き方が今は違うらしい。

```python
>>> print(2 ** 8)
256
>>> 2 ** 8
256
```

3.2 プログラム（モジュール）ファイル

先頭にハッシュバンを書くやり方はRyeでは通じなかった

```shell
#!/usr/bin/env python
#!/usr/bin/python
#!/usr/local/bin/python
```


## II部 ビルトインオブジェクト

### 4章 Pythonのビルトインオブジェクト

#### 4.2 数値

```python
>>> 123 + 222
345
>>> 1.5 * 4
6.0
>>> 2 ** 100
1267650600228229401496703205376
>>> print 3.14 * 2
  File "<stdin>", line 1
    print 3.14 * 2
    ^^^^^^^^^^^^^^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(...)?
>>> print(3.14 * 2)
6.28
>>> import math
>>> math.pi
3.141592653589793
```

#### 4.3 文字列

```python
>>> S = 'Spam'
>>> S
'Spam'
>>> len(S)
4
>>> S[0]
'S'
>>> S[-1]
'm'
>>> line = 'aaa,bbb,ccc,ddd'
>>> line.split(',')
['aaa', 'bbb', 'ccc', 'ddd']
```

#### 4.4 リスト

```python
>>> L = [123, 'spam', 1.23]
>>> L
[123, 'spam', 1.23]
>>> L[0]
123
>>> L[-1]
1.23
>>> L[:-1]
[123, 'spam']
>>> L + [4, 5, 6]
[123, 'spam', 1.23, 4, 5, 6]
>>> L
[123, 'spam', 1.23] # リストの中身は更新されていない
>>> L.append('NY')
>>> L
[123, 'spam', 1.23, 'NY'] # 中身が更新
>>> L.pop(2)
1.23
>>> L
[123, 'spam', 'NY'] # 中身が更新

```

### 4.5 ディクショナリ

```python
>>> D = {'food': 'Spam', 'color': 'Pink'}
>>> D
{'food': 'Spam', 'color': 'Pink'}
>>> D['color']
'Pink'
```

#### 4.6 タプル

```python
>>> T = (1, 2, 3)
>>> T[1]
2
>>> T[1] = 4
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```
##### 4.6.1 なぜタプルが必要なのか

いったん作ると変更ができない。その普遍性が重要になる時がある。

#### 4.8 その他の型

型の確認

```python
>>> type(L)
<class 'list'>
>>> isinstance(L, list)
True
>>> type(T)
<class 'tuple'>
>>> type(S)
<class 'str'>
```

### 5章 数値

```python
>>> 2 * (3 + 4)
14
>>> 2 * 3 + 4
10
>>> 2 + 3 * 4
14
>>> 1 + 2.0 + 3
6.0

>>> import math
>>> oct(8)
'0o10'
```

### 6章 ダイナミックな型付け

#### 6.2 共有リファレンス

```python
>>> a = 3
>>> b = a
>>> a = 'spam'
>>> a
'spam'
>>> b
3
```
#### 6.2.1 共有リファレンスとオブジェクトの上書き

リストは共有されるので更新される

```python
>>> L1 = [2, 3, 4]
>>> L2 = L1
>>> L1[0] = 24

>>> L1
[24, 3, 4]
>>> L2
[24, 3, 4]
```
そのためスライシングしてコピーを使う

```python
>>> L1 = [2, 3, 4]
>>> L2 = L1[:]
>>> L1[0] = 24

>>> L1
[24, 3, 4]
>>> L2
[2, 3, 4]
```

#### 6.2.2 「同等」と「同一」

```python
>>> L = [1, 2, 3]
>>> M = L
>>> L == M
True
>>> L is M #　同じもの
True

>>> M = [1, 2, 3]
>>> L == M
True
>>> L is M # 同じものだけど違う
False

>>> X = 42
>>> Y = 42
>>> X == Y
True
>>> X is Y # これはキャッシュされているので同じ
True
```

### 7章 文字列

- `internationalization` の頭の `i` と最後の `n` の間が18文字あることから、 `i18n` と呼ばれる
- `CODEC` は `COders and DECoders` の略

シンプルあまり難しいところはない


### 8章 リストとディクショナリ

#### 8.1 リスト

- オブジェクトを一定の順序で並べたもの（型は問わない）
- インデックスによって要素にアクセスできる
- 長さを自由に変えられ、複数種の構成要素の混在も可能で、ネストにも対応できる
- シーケンスの一種だが、変更を加えることができる
- オブジェクトリファレンスの配列

#### 8.3 ディクショナリ

- オフセットではなくキーによって要素にアクセスする
- 要素を順不同に並べることができる
- 長さを自由に変えられ、複数種の構成要素の混在も可能（ネストにも対応できる）
- 可変製を持ち、「写像」のカテゴリに属する
  - 順序が一定ではないので、連結、スライシングはできない
- オブジェクトリファレンスのテーブル（ハッシュテーブル）

注意点

- シーケンスと同じ操作はできない
- 存在しないキーを指定して値を代入すると、要素が追加される
- キーは文字列でなくても良い

### 9章 タプル、ファイルオブジェクト、その他

#### 9.1 タプル

- オブジェクトを一定の順序で並べたもの（型は問わない）
- オフセットによってアクセスする
- 不変性シーケンスの一種である
- 長さは固定だが、複数種の構成要素の混在も可能（ネストにも対応できる）
- オブジェクトリファレンスの配列である

####　9.1.2 タプルはなぜ必要か

タプルは不変性オブジェクトであること。これが整合性の面では有利になる場面がある


#### 9.5 リファレンスとコピー

Pythonでは変数がオブジェクトのコピーではなくリファレンスを保持する

```python
>>> X = [1, 2, 3]
>>> X
[1, 2, 3]

>>> L = ['a', X, 'b']
>>> L
['a', [1, 2, 3], 'b']

>>> D = { 'x': X, 'y': 2}
>>> D
{'x': [1, 2, 3], 'y': 2}

>>> X[1] = 'surprise'

>>> X
[1, 'surprise', 3]
>>> L
['a', [1, 'surprise', 3], 'b'] # なんと！
>>> D
{'x': [1, 'surprise', 3], 'y': 2} # なんと！
```

スライシングを使ってコピーする

```python
>>> LL = ['a', X[:], 'b'] #　オブジェクトをコピーする
>>> LL
['a', [1, 'surprise', 3], 'b']

>>> DD = { 'x': X[:], 'y': 2}　#　オブジェクトをコピーする
>>> DD
{'x': [1, 'surprise', 3], 'y': 2}

>>> X[1] = 2

>>> X
[1, 2, 3]
>>> LL
['a', [1, 'surprise', 3], 'b'] #　元のまま
>>> DD
{'x': [1, 'surprise', 3], 'y': 2} #　元のまま
```
### 9.9 ビルトインオブジェクトに関する注意事項

#### 9.9.1 変数にオブジェクトを代入すると、コピーではなく、リファレンスが作られる

コピーではなくリファレンスが作られる
スライシングを使ってコピーを作ること

#### 9.9.2 繰り返し演算によるネスト

```python
>>> X
[1, 2, 3]

>>> XX = X * 4
>>> XX
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]

>>> XXX = [X] * 4
>>> XXX
[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]
```

## III部 ステートメント

### 10章 Pythonのステートメント

#### 10.1 Pythonプログラムの構造

1. プログラムはモジュールから構成される
2. モジュールはステートメントから構成される
3. ステートメントは式から構成される
4. 式により、オブジェクトが作成・処理される
#### 10.2.3 なぜ字下げか

- 字下げでプログラミングの構造を作る
  - その方が見やすいから

### 11章 代入ステートメント、式ステートメント、printステートメント

#### 11.1.5 変数名に関するルール

- `__name__` は使わない
- 予約語は使わない
### 12章 ifステートメント

```python
>>> if x == 'k':
...   print('yes')
... else:
...   print('no')
...
yes
```
#### 12.3 Pythonのブール演算

- 0でない数値、空でないオブジェクトはすべて `true` と解釈される
- 逆に、数値0、空のオブジェクト、 `NON` は `false` と解釈される

```python
>>> a = [ ]
>>> if a:
...   print('true')
... else:
...   print('false')
...
false
```

### 13章 whileループとforループ

#### 13.1 whileループ

```python
x = 10
while x:
  x = x -1
  if x % 2 == 0:
    print x

8
6
4
2
0
```

#### 13.3 forループ

```python
sum = 0
for x in [1, 2, 3, 4]:
  sum = sum + x
  print sum

1
3
6
10
```

#### 13.5.3 シーケンスを更新するforループ

 ```python
 L = [1, 2, 3, 4, 5]
for i in range(len(L)):
  L[i] += 1

print L

[2, 3, 4, 5, 6]
 ```

#### 13.5.5 インデックスと要素を生成する：enumerate関数

```python
S = 'spam'
for (offset, item) in enumerate(S):
  print item, 'appers at offset', offset

s appers at offset 0
p appers at offset 1
a appers at offset 2
m appers at offset 3
```

 #### 13.6 リスト内包表記の概要

```python
>>> L
[1, 2, 3, 4, 5]
>>> L = [x + 10 for x in L] # ワンラインで書けてしまう！
>>> L
[11, 12, 13, 14, 15]
```

### 14章 Pythonのドキュメント

#### 14.2 ステートメント、構文についての注意事項

- コロンを忘れない
- トップレベルのコードは字下げしない
- 対話型コマンドラインでは空白行が意味を持つ
- 字下げに一貫性を持たせる
- Cと混同しない
- できる限りwhileやrangeは使わず、単純なforループを使う
- 可変性を持つオブジェクトの代入には注意
- オブジェクトの上書きを行う関数は値を戻さない
- 関数を呼び出す際には必ずカッコを使用する
- インポート、リロードの際には拡張子やパスは使用しない

## IV部 関数

### 15章 関数の基礎

```python
>>> def times(x, y):
...   return x * y
...
>>> times(2, 4)
8
```

### 16章 スコープと引数

### 17章 関数に関連する高度なテクニック

#### 17.8 関数を作る際のコツ

- できる限り、入力には引数、出力には `return` を使う
- グローバル変数はどうしても必要な場合以外は使用しない
- 関数の役割はひとつに絞る
- 関数はできる限り規模の小さいものにする
- 他のモジュールの変数に直接、変更を加えない

## V部 モジュール

モジュールのやり方とか

## VI部 クラスとオブジェクト指向プログラミング

22章 Pythonでのオブジェクト指向プログラミング
    22.1 クラスとは
    22.2 オブジェクト指向プログラミング
        22.2.1 属性の検索
        22.2.2 クラスとインスタンス
        22.2.3 クラスのメソッド
        22.2.4 オブジェクトツリーの作成
        22.2.5 コードの再利用、カスタマイズ
    22.3 22章のまとめ
 22章の練習問題

23章 クラスのコーディング（基礎）
    23.1 インスタンスオブジェクトは1つのクラスから複数作ることができる
        23.1.1 クラスオブジェクト
        23.1.2 インスタンスオブジェクト
        23.1.3 クラスの実例
    23.2 クラスは継承によってカスタマイズできる
        23.2.1 サブクラスの実例
        23.2.2 クラスとモジュール
    23.3 クラスでは演算子のオーバーロードができる
        23.3.1 演算子のオーバーロードの実例
        23.3.2 演算子のオーバーロードをしないとどうなるか
    23.4 世界一簡単なPythonクラス
    23.5 23章のまとめ
 23章の練習問題

24章 クラスのコーディング（詳細）
    24.1 classステートメント
        24.1.1 classステートメントの書式
        24.1.2 classステートメントの実例
    24.2 メソッド
        24.2.1 メソッドの実例
        24.2.2 スーパークラスのコンストラクタを呼び出す
        24.2.3 特殊なメソッド
    24.3 継承
        24.3.1 属性ツリーの構築
        24.3.2 継承したメソッドのカスタマイズ
        24.3.3 サブクラスのバリエーション
        24.3.4 抽象クラス
    24.4 演算子のオーバーロード
        24.4.1 演算子オーバーロード用のメソッド
        24.4.2 __getitem__：インデクシング
        24.4.3 __getitem__：反復処理への対応
        24.4.4 独自のイテレータの作成
        24.4.5 __getattr__と__setattr__
        24.4.6 属性の隠蔽
        24.4.7 __repr__と__str__
        24.4.8 __radd__
        24.4.9 __call__
        24.4.10 イベントハンドラとしてインスタンスを登録
        24.4.11 __del__
    24.5 名前空間に関する注意事項
        24.5.1 非修飾名
        24.5.2 修飾名：特定のオブジェクトの名前空間
        24.5.3 スコープの決まり方：値が代入される場所
        24.5.4 名前空間の実体はディクショナリ
        24.5.5 __class__属性とクラスの__bases__属性
    24.6 本格的なコード例
    24.7 24章のまとめ
 24章の練習問題

25章 クラスと設計
    25.1 Pythonとオブジェクト指向プログラミング
        25.1.1 引数によって機能が変わるメソッドを作る
    25.2 クラスをデータの集合として使う
    25.3 IS-A関係
    25.4 HAS-A関係
        25.4.1 Processorクラス
    25.5 デリゲーション
    25.6 多重継承
    25.7 ファクトリ
        25.7.1 ファクトリのメリット
    25.8 結合メソッドと非結合メソッド
    25.9 ドキュメンテーション文字列
    25.10 クラスとモジュール
    25.11 25章のまとめ
 25章の練習問題

26章 クラスに関連する高度なテクニック
    26.1 ビルトインオブジェクトの拡張
        26.1.1 デリゲーションによる拡張
        26.1.2 サブクラス作成によるビルトインオブジェクトの機能拡張
    26.2 属性の擬似的な「隠蔽」
        26.2.1 ネームマングリングとは
        26.2.2 ネームマングリングを行うメリット
    26.3 新スタイルクラス
        26.3.1 ダイアモンド継承への対処の違い
        26.3.2 新スタイルクラスのその他の特徴
    26.4 メソッドをインスタンスなしで呼び出すことはできない
        26.4.1 スタティックメソッドとクラスメソッドの使い方
    26.5 関数デコレータ
        26.5.1 関数デコレータの例
    26.6 クラスについての注意事項
        26.6.1 属性変更の副作用
        26.6.2 多重継承したクラスの優先順位
        26.6.3 メソッド、クラスを関数にネストした場合のスコープ
        26.6.4 プログラムの抽象化
    26.7 26章のまとめ
 26章の練習問題
 VI部のまとめ演習

VII部 例外

27章 例外の基礎
    27.1 例外の用途
        27.1.1 例外の役割
    27.2 例外処理の基本
    27.3 try/except/elseステートメント
        27.3.1 tryステートメントのブロック
        27.3.2 elseブロック
        27.3.3 デフォルトの例外処理
        27.3.4 ビルトイン例外の処理
    27.4 try/finallyステートメント
        27.4.1 try/finallyステートメントの例
    27.5 try/except/finallyステートメント
        27.5.1 ネストによってfinallyとexceptを混在させる
        27.5.2 finallyとexceptを混在させたコードの例
    27.6 raiseステートメント
        27.6.1 ユーザ定義例外の発生と処理
        27.6.2 例外とともにデータを渡す
        27.6.3 例外の再発生
    27.7 assertステートメント
        27.7.1 プログラム開発への例外の応用
    27.8 with/asステートメント
        27.8.1 基本的な使い方
        27.8.2 コンテキスト管理プロトコル
    27.9 27章のまとめ
 27章の練習問題

28章 文字列例外とクラス例外
    28.1 文字列例外
        28.1.1 文字列例外は推奨されない
    28.2 クラス例外
        28.2.1 クラス例外の実例
        28.2.2 クラス例外のメリット
        28.2.3 ビルトイン例外
        28.2.4 メッセージの改良
        28.2.5 インスタンスに例外に関する情報を持たせる
    28.3 raiseステートメントの書式
    28.4 28章のまとめ
 28章の練習問題

29章 例外と設計
    29.1 例外ハンドラのネスト
        29.1.1 関数呼び出しによるネスト
        29.1.2 コード上でのネスト
    29.2 例外の活用方法
        29.2.1 例外はエラーに対応するとは限らない
        29.2.2 処理結果の通知
        29.2.3 プログラムのコード全体をtryステートメントの中に入れる
        29.2.4 テストプログラムの作成
        29.2.5 sys.exc_info
    29.3 例外に関する「設計」の問題
        29.3.1 どのコードをtryステートメントに入れるか
        29.3.2 exceptブロックの対応範囲を広げすぎない
        29.3.3 対応範囲が狭すぎるのも問題
    29.4 例外についての注意事項
        29.4.1 文字列例外のマッチングはオブジェクトが同一かどうかを基準に行われる
        29.4.2 余分な例外を捕まえないようにする
    29.5 言語の「コア部分」以外についての解説
        29.5.1 Pythonのツールセット
        29.5.2 大規模プログラムのための開発ツール
    29.6 29章のまとめ
 29章の練習問題
 VII部のまとめ演習

付録A インストールと環境設定
    A.1 Pythonインタプリタのインストール
        A.1.1 Pythonが手元にあるかの確認
        A.1.2 Pythonをどこで入手するか
        A.1.3 インストールの手順
    A.2 Pythonの環境設定
        A.2.1 Pythonに関連する環境変数
        A.2.2 環境変数の設定方法

付録B 演習問題の解答
    B.1 I部　Pythonの基礎知識
    B.2 II部　ビルトインオブジェクト
    B.3 III部　ステートメント
    B.4 IV部　関数
    B.5 V部　モジュール
    B.6 VI部　クラスとオブジェクト指向プログラミング
    B.7 VII部　例外

付録C さらに新しいバージョンのPythonについて
    C.1 新バージョンの位置づけ
        C.1.1 新機能と後方互換性
    C.2 歴史
    C.3 変更点とその裏にある思想
        C.3.1 誤ちを正す
        C.3.2 トレードオフの変更
        C.3.3 新しいパラダイムの導入
        C.3.4 より統一的に
    C.4 おわりに

索引